---
title: "R Notebook"
editor_options: 
  chunk_output_type: console
---


# Description

This script run simulation M times to compare methods, test set = h-step-ahead forecast error


```{r}
library(MASS)
# library(matrixcalc)
library(Matrix)
library(tidyr)
library(ggplot2)

library(fabletools)
library(fable)
library(feasts)
library(tsibble)
library(dplyr)

library(devtools)
load_all()
```


# Parameters

```{r}
# groups <- c(2,2)
groups <- c(4,4,4,4)

T <- 110
h <- 10
Tsplit <- T - h

# structure <- list(
#   groups,
#   as.list(seq(1,length(groups))),
#   list(c(1,2))
# )
structure <- list(
  groups,
  as.list(seq(1,length(groups))),
  list(c(1,2,3,4))
)

(S <- construct_S(
  structure = structure,
  sparse = FALSE,
  ascending = FALSE
))
order_S <- rownames(S)

# ranges for coefs in VAR
diag_range <- c(0.4, 0.9)
offdiag_range <- c(-0.4, 0.4)
```

## Initial Inspect

```{r}

(A <- generate_block_diag(
  groups = groups,
  diag_range = diag_range,
  offdiag_range = offdiag_range
)$A)

rho <- runif(length(groups), 0.6, 0.9)
Sigma <- generate_cor(
  groups = groups,
  rho = rho,
  delta = min(rho) * 0.5,
  # delta = 0.15,
  epsilon = (1-max(rho)) * 0.5,
  # epsilon = 0.15,
  eidim = length(groups)
)
# convert to cov using random sd
Sigma <- convert_cor2cov(Sigma)
# flip signs
V <- diag(x = sample(c(-1,1), size = sum(groups), replace = TRUE))
Sigma <- V %*% Sigma %*% V

Sigma %>% eigen(only.values = TRUE)
Sigma
```



# Function

```{r}
run <- function() {
  
  # -------------------------------------------------
  # Generate parameters for simulating bottom series
  A <- generate_block_diag(
    groups = groups,
    diag_range = diag_range,
    offdiag_range = offdiag_range
  )$A
  
  rho <- runif(length(groups), 0.6, 0.9)
  Sigma <- generate_cor(
    groups = groups,
    rho = rho,
    delta = min(rho) * 0.5,
    # delta = 0.15,
    epsilon = (1-max(rho)) * 0.5,
    # epsilon = 0.15,
    eidim = length(groups)
  )
  # convert to cov using random sd
  Sigma <- convert_cor2cov(Sigma)
  # flip signs
  V <- diag(x = sample(c(-1,1), size = sum(groups), replace = TRUE))
  Sigma <- V %*% Sigma %*% V
  
  # -------------------------------------------------
  # generate bottom-up series and transforming data
  bottom <- simulate_bottom_var(groups, T, intercept = 100, A=A, Sig=Sigma)

  hts_mat <- bottom$Y %*% t(S)
  
  hts <- hts_mat %>% 
    as_tibble() %>% 
    mutate(time = seq(1, nrow(hts_mat))) %>% 
    # select(time, everything()) %>% 
    as_tsibble(index = time) %>% 
    pivot_longer(
      cols = -time,
      names_to = "series",
      values_to = "value"
    )
  
  # -------------------------------------------------
  # Fit and base forecasts
  fit <- hts %>% 
    filter(time <= Tsplit) %>%
    model(
      arima = ARIMA(value)
    )
  fc <- fit |>
    forecast(h = h) |>
    as_fable(response = "value", distribution = value)
  fc <- fc %>% 
    mutate(h = time - Tsplit)
  
  # Get data
  y <- hts_mat[1:Tsplit, order_S]
  actual <- hts_mat[(Tsplit + 1):T, order_S]
  
  y_hat <- fit %>% 
    augment() %>% 
    select(series, .fitted) %>%
    pivot_wider(names_from = series, values_from = .fitted, names_sort = FALSE) %>% 
    as_tibble() %>% 
    select(-time) %>% 
    as.matrix()
  
  base_fc <- fc %>% 
    as_tibble() %>% 
    select(series, .mean, time) %>%
    pivot_wider(names_from = series, values_from = .mean) %>%
    select(-time) %>% 
    as.matrix()
  
  y_hat <- y_hat[, order_S]
  base_fc <- base_fc[, order_S]
  
  # -------------------------------------------------
  # Get covariance estimates
  W_shr <- shrinkage_est(
    y - y_hat
  )
  W_n <- novelist_cv(
    y,
    y_hat,
    S,
    window = round(Tsplit/2),
    message = FALSE
  )
  
  # --------------------------------------------------
  # Reconcile
  recon_mint_shr <- reconcile_mint(base_fc, S, W_shr$cov)
  recon_mint_n <- reconcile_mint(base_fc, S, W_n$cov)
  recon_mint_sample <- reconcile_mint(
    base_fc, S, compute_cov_matrix(y-y_hat, zero_mean = T)
  )
  
  # Organise reconciled results into the fc_new object
  # to_fbl <- function(recon_mint, m_name) {
  #   as_tibble(recon_mint) %>% 
  #   mutate(
  #     h = row_number()
  #   ) %>% 
  #   pivot_longer(
  #     cols = -h,
  #     names_to = "series",
  #     values_to = ".mean"
  #   ) %>%
  #   mutate(
  #     # name of the model
  #     .model = m_name,
  #     time   = h + Tsplit,
  #     value  = NA
  #   ) %>%
  #   select(series, .model, h, time, value, .mean)
  # }
  # 
  # fc_shr <- to_fbl(recon_mint_shr, "mint_shrink")
  # fc_n <- to_fbl(recon_mint_n, "mint_novelist")
  # fc_sample <- to_fbl(recon_mint_sample, "mint_sample")
  # 
  # fc_recon <- fc[0, ] # empty tibble to store results
  # fc_recon <- bind_rows(
  #     fc_recon,
  #     fc_shr,
  #     fc_n,
  #     fc_sample
  #   ) %>% 
  #   mutate(
  #     value = distributional::dist_normal(.mean, NA)
  #   )
  # 
  # fc_full <- bind_rows(fc, fc_recon)
    # fc_full <- fc_full %>% 
    #   mutate(value = distributional::dist_normal(.mean, NA))
  
  SSE <- list(
    base = ((actual - base_fc)^2),
    mint_shr = ((actual - recon_mint_shr)^2),
    mint_n = ((actual - recon_mint_n)^2),
    mint_sample = ((actual - recon_mint_sample)^2)
  )
  
  list(
    SSE = SSE,
    W_shr = W_shr$lambda,
    W_n = c(W_n$lambda, W_n$delta)
  )
}

```

# -- RUN --

```{r}
M <- 200

# ------------------------------------------------
model_names <- c("base", "mint_shr", "mint_n", "mint_sample")
SSE_cum <- setNames(
  lapply(model_names, function(name) {
    matrix(0, h, length(order_S), dimnames = list(1:h, order_S))
  }),
  model_names
)
W_shr_store <- numeric(M)
W_n_store   <- matrix(0, M, 2,
                      dimnames = list(NULL, c("lambda", "delta")))
# ------------------------------------------------

for(i in seq_len(M)[176:200]) {
  cat("Iteration ", i, "\n")
  
  res <- run()
  # add up the SSE matrices
  SSE_cum <- Map(`+`, SSE_cum, res$SSE)
  # store the parameters
  W_shr_store[i]         <- res$W_shr
  W_n_store[i, ]         <- res$W_n
}

MSE <- lapply(SSE_cum, function(mat) mat / M)
```

## Save

```{r}
# Combine all your outputs into a named list
sim_results <- list(
  MSE    = MSE,    # or averaged MSE
  W_shr  = W_shr_store,       # can be a list of matrices or one matrix
  W_n    = W_n_store          # same
)

# Save to file
S_string <- paste0("S", sum(groups))
for (i in 2:length(structure)) {
  S_string <- paste0(S_string, "-", length(structure[[i]]))
}
file <- paste0(
  S_string,
  "_T", T-h,
  "_M", M
)
saveRDS(sim_results, file = paste("sim/sim_results/", file, ".rds", sep = ""))
```

## Inspect

```{r}
library(purrr)

MSE

MSE_ts <- imap_dfr(MSE, function(mat, model_name) {
    as_tibble(mat) %>%
      mutate(h = row_number()) %>%
      pivot_longer(cols = -h, names_to = "series", values_to = "MSE") %>%
      mutate(
        .model = model_name,
      ) %>%
      select(.model, series, h, MSE)
  }) %>%
  as_tsibble(key = c(.model, series), index = h)

MSE_ts |> group_by(.model) |> index_by(h) |>
  summarise(mse = mean(MSE)) |>
  ggplot(aes(x = h, y = mse, color = .model)) +
    geom_line() +
    labs(x = "Horizon", y = "MSE") +
    theme_minimal()
```




