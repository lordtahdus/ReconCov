---
title: "R Notebook"
# output: html_notebook
editor_options: 
  chunk_output_type: console
---

```{r}
library(tidyverse)
library(MASS)
library(matrixcalc)
library(Matrix)
```

```{r}
# --- Simulation Parameters ---
T <- 1000           # number of time points
p <- 10             # number of series (variables)

# Create a true covariance matrix with moderate correlations
Sigma_true <- matrix(0.3, nrow = p, ncol = p)
diag(Sigma_true) <- 1.2

# # Create a matrix of random values
# M <- matrix(runif(p^2, min = -0.5, max = 0.5), nrow = p, ncol = p)
# # Force symmetry by averaging with its transpose
# M <- (M + t(M)) / 2
# diag(M) <- 1
# Sigma_true <- as.matrix(nearPD(M)$mat)

  

# --- Simulate Synthetic Residuals ---
# Generate T residuals from a multivariate normal with covariance Sigma_true
res <- mvrnorm(n = T, mu = rep(0, p), Sigma = Sigma_true)

# covm <- cov(res)          # Sample covariance matrix (p x p)
# r <- cov2cor(covm)        # Sample correlation matrix
# 
# is.positive.definite(covm)

```

```{r check PD}
eigenvalues <- eigen(r, only.values = TRUE)[["values"]]
if (any(eigenvalues < 1e-8)) {
  print("Non-positive Definite")
} else print("Positive Definite")
```


```{r}
T <- 100           # number of observations (T < p)
p <- 200 
 
r <- 10
F <- matrix(rnorm(p * r), nrow = p)       # factor loadings
Sigma <- F %*% t(F)                        # low-rank covariance matrix
# Add a very small diagonal noise to ensure PD
Sigma <- Sigma + diag(1e-4, p)

# is.positive.definite(Sigma)
qr(Sigma)$rank
eigen(Sigma, only.values = TRUE)[["values"]] %>% plot()
```











## Sanity Check: Shrinkage Estimator

```{r}
# --- Simulation Parameters ---
T <- 20           # number of time points
p <- 5             # number of series (variables)

# Create a true covariance matrix with moderate correlations
Sigma_true <- matrix(0.3, nrow = p, ncol = p)
diag(Sigma_true) <- 1.1
resid <- mvrnorm(n = T, mu = rep(0, p), Sigma = Sigma_true)
```


```{r}
shrinkage_est_fable <- function(resid) {
  n = nrow(resid)
  covm <- crossprod(stats::na.omit(resid)) / n # assume resid = 0
  tar <- diag(apply(resid, 2, compose(crossprod, stats::na.omit))/n) # SSR/n 
  corm <- cov2cor(covm)
  xs <- scale(resid, center = FALSE, scale = sqrt(diag(covm)))
  xs <- xs[stats::complete.cases(xs),]
  v <- (1/(n * (n - 1))) * (crossprod(xs^2) - 1/n * (crossprod(xs))^2)
  diag(v) <- 0    
  corapn <- cov2cor(tar)
  d <- (corm - corapn)^2
  lambda <- sum(v)/sum(d)
  lambda <- max(min(lambda, 1), 0)
  W <- lambda * tar + (1 - lambda) * covm
  return(W)
}

# CHECKING MY FUNCTION vs. FABLE FUNCTION
if (all(shrinkage_est(resid)$cov.shr == shrinkage_est_fable(resid))) TRUE else FALSE

# shrinkage_est(resid, zero_mean = FALSE)
# shrinkage_est(resid)

```

## Sanity Check: NOVELIST Estimator

```{r}
library(devtools)
devtools::load_all("D:/Github/Honours-Research/novelist")
```

```{r}
W.1 <- novelist.cov.cv(
  resid, data = TRUE, is.cov = FALSE, 
  lambda = c(0.5, 0.5), 
  # delta = 0.5,
  CV = TRUE, CV.cov = FALSE,
  rep.cv = 2
)$cov.novel 

W.2 <- novelist_est(
  resid, delta = 0.5, 
  # lambda = 0.5, 
  zero_mean = FALSE
)$cov.novelist

abs(W.1 - W.2)
# delta.star(resid, c(0.5, 0.5))
```

```{r}
W.1 <- novelist.cov.cv(
  resid, data = TRUE, is.cov = FALSE, 
  lambda = 0.5, 
  delta = 0.5,
  CV = FALSE, CV.cov = FALSE,
)$cov.novel[,,1,1]

W.2 <- novelist_est(
  resid, delta = 0.5, 
  lambda = 0.5,
  zero_mean = FALSE
)$cov.novelist

W.1 == W.2
```


```{r}
shrinkage_est(
  resid,
  lambda = 0.9,
  zero_mean = TRUE
)$cov.shr - novelist_est(
  resid, delta = 1, 
  lambda = 0.9,
  zero_mean = TRUE
)$cov.novelist
```

```{r}
# append this result (a list with 2 elements) to 2 objects
novelist_est(
  resid, delta = 0.5, 
  lambda = 0.5,
  zero_mean = FALSE
)$cov_novelist
```


