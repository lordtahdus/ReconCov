---
title: "R Notebook"
# output: html_notebook
---

```{r}
library(tidyverse)
library(MASS)
library(matrixcalc)
library(Matrix)
library(bench)
```


## Simulate synthetic residuals

**Case 1**

"barelyPD": Uses a low-rank factor model (rank = 10) and adds a tiny diagonal value (1e-4) to force positive definiteness.

**Case 2**

"highCorr": Constructs a constant correlation matrix with high off-diagonal correlation (rho = 0.9) and random variances.

**Case 3**

"random": Uses the cross-product of a random matrix.

**Case 4**

"blockDiag": Creates a block-diagonal structure where each block has high within-block correlation, then adds a slight mix between blocks.

**Case 5**

"PCprominant": Creates residuals that have some prominant PC structures, aim to assess the PC-adjusted NOVELIST


```{r simulation function}
set.seed(123) 

T <- 100         
p <- 20       

# Function to simulate different Sigma_true cases
simulate_Sigma <- function(p, case) {
  if(case == "barelyPD") {
    # ----- Case 1: Barely positive definite (nearly singular)
    # Create a low-rank factor model: rank r << p
    r <- 10
    F <- matrix(rnorm(p * r), nrow = p)       # factor loadings
    Sigma <- F %*% t(F)                        # low-rank covariance matrix
    # Add a very small diagonal noise to ensure PD
    Sigma <- Sigma + diag(1e-4, p)
    
  } else if(case == "highCorr") {
    # ----- Case 2: Highly correlated covariance matrix
    rho <- 0.9
    # Random variances between 1 and 2 (to make a covariance matrix)
    variances <- runif(p, min = 1, max = 2)
    R <- matrix(rho, nrow = p, ncol = p)
    diag(R) <- 1
    Sigma <- diag(sqrt(variances)) %*% R %*% diag(sqrt(variances))
    
  } else if(case == "random") {
    # ----- Case 3: Random covariance matrix
    # Generate a random matrix and use its cross-product as covariance
    A <- matrix(rnorm(p * p), nrow = p)
    Sigma <- crossprod(A) / p  # scale to keep variances moderate
    
  # } else if(case == "blockDiag") {
  #   # ----- Case 4: Block-diagonal structure with high within-block correlations
  #   numBlocks <- 4
  #   blockSize <- floor(p / numBlocks)
  #   Sigma <- matrix(0, nrow = p, ncol = p)
  #   
  #   for(i in 1:numBlocks) {
  #     idx <- ((i - 1) * blockSize + 1):(i * blockSize)
  #     # Within-block: high correlation (varying between 0.8 and 1)
  #     rho <- runif(1, 0.8, 1)
  #     variances <- runif(length(idx), 1, 3)
  #     R_block <- matrix(rho, nrow = length(idx), ncol = length(idx))
  #     diag(R_block) <- 1
  #     Sigma[idx, idx] <- diag(sqrt(variances)) %*% R_block %*% diag(sqrt(variances))
  #   }
  #   # For any remaining rows (if p %% numBlocks != 0)
  #   if(p %% numBlocks != 0) {
  #     idx <- (numBlocks * blockSize + 1):p
  #     Sigma[idx, idx] <- diag(runif(length(idx), 1, 3))
  #   }
  #   # Add a small random noise to off-diagonals to mix blocks slightly
  #   Sigma <- Sigma + 0.05 * matrix(runif(p * p, min = -1, max = 1), nrow = p)
  #   # Ensure the result is positive definite
  #   Sigma <- as.matrix(nearPD(Sigma)$mat)
  #   return(Sigma)
    
  } else {
    stop("Unknown case")
  }
  # Check PD
  eigenvalues <- eigen(Sigma, only.values = TRUE)[["values"]]
  if (any(eigenvalues < 1e-8)) {
    stop("Simulation error: Non-positive Definite")
  }
  return(Sigma)
}

# --- Simulate Sigma for Residuals Simulation ---
Sigma_barely   <- simulate_Sigma(p, "barelyPD")
Sigma_highCorr <- simulate_Sigma(p, "highCorr")
Sigma_random   <- simulate_Sigma(p, "random")
# Sigma_block    <- simulate_Sigma("blockDiag")

# --- Simulate Residuals ---
res_barely   <- mvrnorm(n = T, mu = rep(0, p), Sigma = Sigma_barely)
res_highCorr <- mvrnorm(n = T, mu = rep(0, p), Sigma = Sigma_highCorr)
res_random   <- mvrnorm(n = T, mu = rep(0, p), Sigma = Sigma_random)
# res_block    <- mvrnorm(n = T, mu = rep(0, p), Sigma = Sigma_block)


```






